function [vertices] = points(group, start)%% TOP RIGHT BOT LEFT% find voxels with highest y and z values of the group[highestz,indextop] = max(group(:,2));[lowestz,indexbot] = min(group(:,2));[highesty,indexright] = max(group(:,1));[lowesty,indexleft] = min(group(:,1));% find all options for the top/bot/right/left voxeloptionstop = find(group(:,2) == highestz);optionsbot = find(group(:,2) == lowestz);optionsright = find(group(:,1) == highesty);optionsleft = find(group(:,1) == lowesty);% if there are multiple options for the top/bot/right/left voxel% choose the one closest to start (brightest) voxel% topif size(optionstop,1) > 1    diff = zeros(size(optionstop));    for i = 1:size(optionstop,1)        diff(i) = abs(group(optionstop(i),1) - start(1,1));    end    [mindiff,index] = min(diff);    indextop = optionstop(index);end% bottomif size(optionsbot,1) > 1    diff = zeros(size(optionsbot));    for i = 1:size(optionsbot,1)        diff(i) = abs(group(optionsbot(i),1) - start(1,1));    end    [mindiff,index] = min(diff);    indexbot = optionsbot(index);end% leftif size(optionsleft,1) > 1    diff = zeros(size(optionsleft));    for i = 1:size(optionsleft,1)        diff(i) = abs(group(optionsleft(i),2) - start(1,2));    end    [mindiff,index] = min(diff);    indexleft = optionsleft(index);end% rightif size(optionsright,1) > 1    diff = zeros(size(optionsright));    for i = 1:size(optionsright,1)        diff(i) = abs(group(optionsright(i),2) - start(1,2));    end    [mindiff,index] = min(diff);    indexright = optionsright(index);end% set top/bot/right/left voxeltop = group(indextop,:);bot = group(indexbot,:);right = group(indexright,:);left = group(indexleft,:);%% CORNERS% get the maximum y and z coordinates by which the group is boundmaxz = max(group(:,2));minz = min(group(:,2));maxy = max(group(:,1));miny = min(group(:,1));% TO DO : what if c>(cols-1)cols = maxy-miny;rows = maxz-minz;a = min(cols,rows)+1; % maximal amount of candidates for corner voxel%%%%%% BOTLEFT% comments only here, same idea for topleft/topright/botrightc = 2; % counterbotleft = [miny,minz];% botleft can be part of group or a background voxel in bounding box[bool, loc] = ismember(botleft,group, 'rows');% botleft is part of groupif bool == 1    botleft = group(loc,:);    % botleft is not part of group,    % explore c = 2 voxels on diagonal next to botleft in bounding box,    % if these voxels are still not part of group, increment c and explore next    % diagonalelse    for k = 1:c        cand = zeros([c 2]);        bool = zeros([c 1]); loc = zeros([c 1]); dis = [];        counter = 0;                % find the coordinates of the candidates        % check whether they are a part of the group        % if so, calculate distance between candidate and start voxel        for i = 1:c            cand(i,:) = [miny+c-i,minz+i-1];            [bool(i), loc(i)] = ismember(cand(i,:),group,'rows');            if bool(i) == 1                counter = counter + 1;                dis(counter,1:2) = cand(i,:);                dis(counter,3) = norm(start-cand(i,:));                dis(counter,4) = loc(i);            end        end                % increment c and continue when none of candidates is part of group        if size(dis,1) == 0            c = c+1;        end                % set botleft when only one candidate is part of group, break        if size(dis,1) == 1            botleft = [dis(1,1),dis(1,2)];        end                % set botleft to be the candidate closest to start voxel when        % multiple candidates are part of group, break        if size(dis,1) > 1            [closest,index] = min(dis(:,3));            botleft = [dis(index,1),dis(index,2)];        end            endend%%%%%% TOPLEFT% comments see botleftc = 2;topleft = [miny,maxz];[bool, loc] = ismember(topleft,group, 'rows');if bool == 1    topleft = group(loc,:);else    for k = 1:c        cand = zeros([c 2]);        bool = zeros([c 1]); loc = zeros([c 1]); dis = [];        counter = 0;                for i = 1:c            cand(i,:) = [miny+i-1,maxz-c+i];            [bool(i), loc(i)] = ismember(cand(i,:),group,'rows');            if bool(i) == 1                counter = counter + 1;                dis(counter,1:2) = cand(i,:);                dis(counter,3) = norm(start-cand(i,:));                dis(counter,4) = loc(i);            end        end                if size(dis,1) == 0            c = c+1;        end                if size(dis,1) == 1            topleft = [dis(1,1),dis(1,2)];        end                if size(dis,1) > 1            [closest,index] = min(dis(:,3));            topleft = [dis(index,1),dis(index,2)];        end            endend%%%%%% TOPRIGHT% comments see botleftc = 2;topright = [maxy,maxz];[bool, loc] = ismember(topright,group, 'rows');if bool == 1    topright = group(loc,:);else    while 1        cand = zeros([c 2]);        bool = zeros([c 1]); loc = zeros([c 1]); dis = [];        counter = 0;                for i = 1:c            cand(i,:) = [maxy-i+1,maxz-c+i];            [bool(i), loc(i)] = ismember(cand(i,:),group,'rows');            if bool(i) == 1                counter = counter + 1;                dis(counter,1:2) = cand(i,:);                dis(counter,3) = norm(start-cand(i,:));                dis(counter,4) = loc(i);            end        end                if size(dis,1) == 0            c = c+1;        end                if size(dis,1) == 1            topright = [dis(1,1),dis(1,2)];            break        end                if size(dis,1) > 1            [closest,index] = min(dis(:,3));            topright = [dis(index,1),dis(index,2)];            break        end            endend%%%%%% BOTRIGHT% comments see botleftc = 2; % counterbotright = [maxy,minz];[bool, loc] = ismember(botright,group, 'rows');if bool == 1    botright = group(loc,:);else    while 1        cand = zeros([c 2]);        bool = zeros([c 1]); loc = zeros([c 1]); dis = [];        counter = 0;                for i = 1:c            cand(i,:) = [maxy-c+i,minz+i-1];            [bool(i), loc(i)] = ismember(cand(i,:),group,'rows');            if bool(i) == 1                counter = counter + 1;                dis(counter,1:2) = cand(i,:);                dis(counter,3) = norm(start-cand(i,:));                dis(counter,4) = loc(i);            end        end                if size(dis,1) == 0            c = c+1;        end                if size(dis,1) == 1            botright = [dis(1,1),dis(1,2)];            break        end                if size(dis,1) > 1            [closest,index] = min(dis(:,3));            botright = [dis(index,1),dis(index,2)];            break        end            endend%% OUTPUTvertices = [top;topright;right;botright;bot;botleft;left;topleft];return;%% MASK (not to hand in but for ourselves to take a look at the vertices in ITK-SNAP)datapath = "C:\Users\20194695\Documents\Team_Challenge\data";patients = loadpatient(datapath, 2, ["STIR", "tracts_C6R"]);mask = zeros(168,85,168);mask(95,51,76) = 1;mask(95,49:51,77) = 1;mask(95,49:51,78) = 1;mask(95,48:51,79) = 1;mask(95,48:50,80) = 1;mask(95,48:49,81) = 1;mask(95,48:49,82) =1;mask(95,48,83) = 1;stir = patients{1,2}{1,1};nerve = stir .* mask;niftiwrite(nerve,"nerve");per = permute(nerve,[3 2 1]);imtool(per(:,:,95),[0 137]);pointsmask = zeros(168,85,168);for i=1:8    pointsmask(95,vertices(i,1),vertices(i,2)) = 1;endniftiwrite(pointsmask,"pointsmask");% to view in ITK-SNAP, open nerve.nii and mask with pointsmask.nii% look at slice x=95end